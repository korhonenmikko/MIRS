import "GSp_data.m" : 
GSpSOLR,            REC_GOPlus12_G10,   REC_GSp4_3_G2,      REC_GSp6_5_G14,
REC_GOMinus10_G1,   REC_GOPlus12_G11,   REC_GSp4_3_G3,      REC_GSp6_5_G15,
REC_GOMinus10_G2,   REC_GOPlus12_G12,   REC_GSp4_3_G4,      REC_GSp6_5_G2,
REC_GOMinus10_G3,   REC_GOPlus12_G13,   REC_GSp4_5_G1,      REC_GSp6_5_G3,
REC_GOMinus10_G4,   REC_GOPlus12_G2,    REC_GSp4_5_G2,      REC_GSp6_5_G4,
REC_GOMinus10_G5,   REC_GOPlus12_G3,    REC_GSp4_5_G3,      REC_GSp6_5_G5,
REC_GOMinus10_G6,   REC_GOPlus12_G4,    REC_GSp4_5_G4,      REC_GSp6_5_G6,
REC_GOMinus10_G7,   REC_GOPlus12_G5,    REC_GSp4_5_G5,      REC_GSp6_5_G7,
REC_GOMinus10_G8,   REC_GOPlus12_G6,    REC_GSp4_5_G6,      REC_GSp6_5_G8,
REC_GOMinus12_G1,   REC_GOPlus12_G7,    REC_GSp4_5_G7,      REC_GSp6_5_G9,
REC_GOMinus12_G2,   REC_GOPlus12_G8,    REC_GSp4_7_G1,      REC_GSp8_3_G1,
REC_GOMinus12_G3,   REC_GOPlus12_G9,    REC_GSp4_7_G10,     REC_GSp8_3_G10,
REC_GOMinus12_G4,   REC_GOPlus4_G1,     REC_GSp4_7_G2,      REC_GSp8_3_G11,
REC_GOMinus12_G5,   REC_GOPlus6_G1,     REC_GSp4_7_G3,      REC_GSp8_3_G12,
REC_GOMinus12_G6,   REC_GOPlus6_G2,     REC_GSp4_7_G4,      REC_GSp8_3_G13,
REC_GOMinus12_G7,   REC_GOPlus8_G1,     REC_GSp4_7_G5,      REC_GSp8_3_G14,
REC_GOMinus12_G8,   REC_GOPlus8_G2,     REC_GSp4_7_G6,      REC_GSp8_3_G15,
REC_GOMinus12_G9,   REC_GOPlus8_G3,     REC_GSp4_7_G7,      REC_GSp8_3_G16,
REC_GOMinus2_G1,    REC_GOPlus8_G4,     REC_GSp4_7_G8,      REC_GSp8_3_G17,
REC_GOMinus4_G1,    REC_GSp4_11_G1,     REC_GSp4_7_G9,      REC_GSp8_3_G18,
REC_GOMinus6_G1,    REC_GSp4_11_G10,    REC_GSp6_3_G1,      REC_GSp8_3_G2,
REC_GOMinus6_G2,    REC_GSp4_11_G11,    REC_GSp6_3_G2,      REC_GSp8_3_G3,
REC_GOMinus8_G1,    REC_GSp4_11_G2,     REC_GSp6_3_G3,      REC_GSp8_3_G4,
REC_GOMinus8_G2,    REC_GSp4_11_G3,     REC_GSp6_3_G4,      REC_GSp8_3_G5,
REC_GOMinus8_G3,    REC_GSp4_11_G4,     REC_GSp6_3_G5,      REC_GSp8_3_G6,
REC_GOPlus10_G1,    REC_GSp4_11_G5,     REC_GSp6_3_G6,      REC_GSp8_3_G7,
REC_GOPlus10_G2,    REC_GSp4_11_G6,     REC_GSp6_5_G1,      REC_GSp8_3_G8,
REC_GOPlus10_G3,    REC_GSp4_11_G7,     REC_GSp6_5_G10,     REC_GSp8_3_G9,
REC_GOPlus10_G4,    REC_GSp4_11_G8,     REC_GSp6_5_G11,
REC_GOPlus10_G5,    REC_GSp4_11_G9,     REC_GSp6_5_G12,
REC_GOPlus12_G1,    REC_GSp4_3_G1,      REC_GSp6_5_G13
;

import "GSp_gens.m" : 
CDEfirstpairSP,       CDseqtoeltMinus,      CmapGO,               EmapSP,
CDEseqtoelt,          CDseqtoeltPlus,       CmapSP,               sp2word,
CDEsequenceSP,        CDsequenceMinus,      DmapGO,               wordminimizerMinus,
CDEwordSP,            CDsequencePlus,       DmapSP,               wordminimizerPlus,
CDfirstpairMinus,     CDwordMinus,          DmapminusGO,
CDfirstpairPlus,      CDwordPlus,           EmapGO
;

//
// for r prime, finds a solution to a^2 + b^2 = -1 (mod r)
// if r = 1 mod 4, take b = 0 and a^2 = -1 
// if r = 3 mod 4, find a s.t. a^2 + 1 is a nonresidue, then choose b^2 = -(a^2+1).
a2b2sol := function(r)

	a := GF(r)!0; b := GF(r)!0;
		
		if r mod 4 eq 1 then
			a := Root(GF(r)!(-1),2);
			b := GF(r)!0;
			return a,b;
		end if;
		
	for j in [1..r] do
		if LegendreSymbol(1+j^2,r) eq -1 then
			a := GF(r)!j;
			break;
		end if;
	end for;

	b := Root(GF(r)!(-1-a^2), 2);
		
	return a,b;
	
end function;

// SingerTypeB0(n,q):
// As an alternative to this function, you could just: 
// 		return SemiLinearGroup(GL(1,q^n), GF(q));
//
// Take \zeta primitive element of GF(q^n)
// as GF(q)-linear maps on GF(q^n):
// f(v) = \zeta * v 
// phi(v) = v^q
//
// phi * f * phi = f^q.
// f order q^n - 1.
// phi order v.
//
// This function returns: G,phi,f
// where G is the subgroup of GL(n,q) generated by phi and f.
//
SingerTypeB0 := function(n,q) 

	if n eq 1 then
		return GL(1,q),Matrix(GF(q),1,1,[PrimitiveElement(GF(q))]),GL(1,q)!1;
	end if;

	K := GF(q^n);
	R := PolynomialRing(GF(q));

	z := PrimitiveElement(K);
	pol := MinimalPolynomial(z, GF(q));

	A := Transpose(CompanionMatrix(pol));

	B := ZeroMatrix(GF(q), n,n);

	R := quo<R | pol>;

	for i in [1..n] do
	c := Coefficients((R.1)^(q*(i-1)));
	for j in [1..Min(n,#c)] do
		B[j][i] := c[j];
	end for;
	end for;

	// depending on what relation is preferred
	// B := B^-1;

	return sub<GL(n,q) | A,B>, A, B;
	// properties:
	// A order q^n - 1
	// B order n
	// B * A * B^-1 = A^q
end function;

//
// This function returns generators for the normalizer of an 
// absolutely irreducible extraspecial subgroup of GL(r^l, q).
//
// r prime.
// l >= 1.
// q prime power such that r divides q-1.
// GType must be equal to "+" or "-"; and GType = "-" only allowed for r = 2.
//
// if r = 2 and GType = "+"; 2_{+}^{1+2l}
// if r = 2 and GType = "-"; 2_{-}^{1+2l}
//
// return At,Bt,Ct,Dst,Et
//
// At = [A_1, ..., A_l]
// Bt = [B_1, ..., B_l]
// Ct = [C_1, ..., C_l]
//
// if r = 2 and GType = "-", then A_l,B_l,C_l are the minus type versions
//
// Dst = [D_{1,2}, D_{1,3}, ..., D_{1,l}, ..., D_{l-1,l}]
// Et = [E_1, ..., E_l]
// notes:
// if r = 2 and GType = "+", then E_t = 1 for all 1 <= t <= l 
// if r = 2 and GType = "-", then E_t = 1 for all 1 <= t <= l-1.
// if r = 2 and GType = "-", then D_{1,l} is the minus type version
//
ExtraSpecialNormalizerGenerators := function(r,l,q : GType := "+")

	K := GF(q);
	z := PrimitiveElement(K);

	// need to require that r divides q - 1
	// extraspecial group of order r^(1+2l)
	th := z^((q - 1) div r);
	f := ScalarMatrix(r^l, z);
	At := [];
	Bt := [];
	Ct := [];
	Dst := [];
	Et := [];

	if (r ne 2) or (GType eq "+") then

		// note that Binomial(0,2) = Binomial(1,2) = 0; so in case r = 2 we have E = 1.
		A := DiagonalMatrix(K, [th^i : i in [0..(r-1)]]);
		B := Matrix(K, r, r, [<i+1,i,1> : i in [1..(r-1)]] cat [<1,r,1>]);
		C := Matrix(K, r, r, [<i,j,th^((i-1)*(j-1))> : i,j in [1..r]]);
		E := DiagonalMatrix(K, [th^(Binomial(i,2)) : i in [0..(r-1)]]);      
		I := IdentityMatrix(K, r);

		//
		// as a basis for r^l-dimensional vector space, we have tensor products
		// v_{x_1, ..., x_l} = v_{x_1} x ... x v_{x_l}, where 0 <= x_1, ..., x_l < r
		// here v_0, v_1, ..., v_{r-1} basis for the vector space of A,B,C,E.
		// 
		// At = [A_1, ..., A_l]
		// with A_t = I x ... x I x A x I ... x I; with A as the factor number t.
		// similarly B_t,C_t,E_t.
		// A_t multiplies v_{x_1, ..., x_l} with th^(x_t)
		// B_t maps v_{x_1, ..., x_l} to v_{x_1,...,x_{t-1}, x_t + 1, x_{t+1}, ..., x_l}
		// C_t maps ...
		// E_t multiplies v_{x_1, ..., x_l} with th^(x_t*(x_t-1)/2)
		//
		for i in [1..l] do
			if i eq 1 then
				tempA := A;
				tempB := B;
				tempC := C;
				tempE := E;
			else
				tempA := I;
				tempB := I;
				tempC := I;
				tempE := I;
			end if;

			for j in [2..l] do
				if j eq i then
					tempAX := A;
					tempBX := B;
					tempCX := C;
					tempEX := E;
				else
					tempAX := I;
					tempBX := I;
					tempCX := I;
					tempEX := I;
				end if;

				tempA := TensorProduct(tempA, tempAX);
				tempB := TensorProduct(tempB, tempBX);
				tempC := TensorProduct(tempC, tempCX);
				tempE := TensorProduct(tempE, tempEX);
			end for;

			At[i] := tempA;
			Bt[i] := tempB;
			Ct[i] := tempC;
			Et[i] := tempE;
		end for;

		// construct D_{st} 1 <= s < t <= l
		// D_{st} multiplies v_{x_1, ..., x_l} with th^(x_s x_t).
		//
		// w_j = v_{x_1,...,x_l} with 0 <= j < r^l
		// then
		// j = x_l + x_{l-1} * r + ... + x_1 * r^(l-1)
        // so with base r expansion, we get the index j of v_{x_1, ..., x_l}
		// conversely for w_j, with base r expansion of j we get the values of x_1, ..., x_l
        
		Dst := []; 
		for s in [1..l] do
			for t in [s+1..l] do
				tempD := IdentityMatrix(K, r^l);

				for i in [1..r^l] do
					// sequence [i_1, ..., i_{l}]
					iseq := IntegerToSequence(i-1,r);
					iseq := iseq cat [0 : j in [1..(l-#iseq)]];
					ixt := iseq[l-t+1];
					ixs := iseq[l-s+1];
					tempD[i][i] := th^(ixt*ixs);
				end for;

				Append(~Dst, tempD);
			end for;
		end for;

	elif (r eq 2) and (GType eq "-") then

		A := DiagonalMatrix(K, [1,-1]);
		B := Matrix(K, 2,2, [0,1, 1,0]);
		C := Matrix(K, 2,2, [1,1, 1,-1]);
		
		I := IdentityMatrix(K,2);

		a,b := a2b2sol(Characteristic(K));
		Am := Matrix(K, 2,2, [a,b,b,-a]);
		Bm := Matrix(K, 2,2, [0,-1,1,0]);
		Cm := Am + Bm;
		Em := Am + I;

		for i in [1..l] do
			if (i eq 1) and (i lt l) then
				tempA := A;
				tempB := B;
				tempC := C;
				tempE := I;
			elif (i eq 1) and (i eq l) then
				tempA := Am;
				tempB := Bm;
				tempC := Cm;
				tempE := Em;
			else
				tempA := I;
				tempB := I;
				tempC := I;
				tempE := I;
			end if;

			for j in [2..l] do
				if (j eq i) and (j ne l) then
					tempAX := A;
					tempBX := B;
					tempCX := C;
					tempEX := I;
				elif (j eq i) and (j eq l) then
					tempAX := Am;
					tempBX := Bm;
					tempCX := Cm;
					tempEX := Em;
				else
					tempAX := I;
					tempBX := I;
					tempCX := I;
					tempEX := I;
				end if;

				tempA := TensorProduct(tempA, tempAX);
				tempB := TensorProduct(tempB, tempBX);
				tempC := TensorProduct(tempC, tempCX);
				tempE := TensorProduct(tempE, tempEX);
			end for;

			At[i] := tempA;
			Bt[i] := tempB;
			Ct[i] := tempC;
			Et[i] := tempE;
		end for;		

        //
		// construct D_{st} 1 <= s < t <= l-1
		// D_{st} multiplies v_{x_1, ..., x_l} with th^(x_s x_t).
		//
		// w_j = v_{x_1,...,x_l} with 0 <= j < r^l
		// then
		// j = x_l + x_{l-1} * r + ... + x_1 * r^(l-1)
        // so with base r expansion, we get the index j of v_{x_1, ..., x_l}
		// conversely for w_j, with base r expansion of j we get the values of x_1, ..., x_l
        //
		// D_{sl} for 1 <= s <= l-1 is defined by:
		// D_{sl} * v_{x_1, ..., x_l}   =  A_l * v_{x_1, ..., x_l},  if x_s = 1.
		//                                 v_{x_1, ..., x_l},        if x_s = 0.
		// So for construction: first take D_{sl} = A_l;
		// then set columns of D_{sl} corresponding to v_{x_1, ..., x_l} with x_s = 0 as (0,...,0,1,0,..,0).
		//

		Dst := []; 
		for s in [1..l] do
			for t in [s+1..l] do
				if t lt l then
					tempD := IdentityMatrix(K, r^l);

					for i in [1..r^l] do
						// sequence [i_1, ..., i_{l}]
						iseq := IntegerToSequence(i-1,r);
						iseq := iseq cat [0 : j in [1..(l-#iseq)]];
						ixt := iseq[l-t+1];
						ixs := iseq[l-s+1];
						tempD[i][i] := th^(ixt*ixs);
					end for;

					Append(~Dst, tempD);

				elif t eq l then
					tempD := At[l];
					for i in [1..r^l] do
						// sequence [i_1, ..., i_{l}]
						iseq := IntegerToSequence(i-1,r);
						iseq := iseq cat [0 : j in [1..(l-#iseq)]];
						ixs := iseq[l-s+1];
						if ixs eq 0 then
							MultiplyColumn(~tempD, 0, i);
							tempD[i][i] := 1;
						end if;
					end for;

					Append(~Dst, tempD);

				end if;
			end for;

		end for;

	end if;

	return f,At,Bt,Ct,Dst,Et;
end function;

//
// return the "base" for groups of type B_0 in GL(n,q), where
// n = mu * v, and |F_0| = q^v - 1.
// Need to assume: for every prime divisor r of mu, we have r dividing q^v - 1.
// Let r_1, ..., r_k be the prime factors of mu.
// R_i = extraspecial of exponent r_i or 4.
//
// This function returns generators for the normalizer N_{GL(n,q)}(F_0,R_1, ...,R_k):
// F_0 = <f>
// A_0 = <f, R_1, ..., R_k>
// R_i generated by A_1, B_1, ...
// include generators C_t, D_st, etc. acting on R_i's
// finally \psi of order v
//  
// GType = "-" if r_i = 2 and R_i is of minus type.
//
// return value: 
// A_LISTS, B_LISTS, C_LISTS, D_LISTS, E_LISTS, f, phi;
// A_LISTS: list [U_1, ..., U_k]; where U_i = generators {A_i} for R_i
// B_LISTS: list [U_1, ..., U_k]; where U_i = generators {B_i} for R_i
// etc for C_LISTS, D_LISTS, E_LISTS for the normalizer of R_i.
// phi is such that phi*f*phi^-1 = f^q
// f has order q^v - 1.
SingerTypeB0base := function(mu,v,q : GType := "+")

	// mu = 1: GammaL(1,q^v) < GL(v,q) constructed earlier.
	if mu eq 1 then
		G,f,phi := SingerTypeB0(v,q);
		return [], [], [], [], [], f, phi;
	end if;

	// for the rest of the function, we have mu > 1.
	n := mu*v;
	M := Factorization(mu);

	K := GF(q^v);
	z := PrimitiveElement(K);
    w := Generator(K, GF(q));
	R := PolynomialRing(GF(q));
	
    // We define f0 and phi0 with respect to basis 1,w,...,w^(v-1) of K/GF(q).

    // this is the minimal polynomial of w = Generator(K, GF(q)) over GF(q).
    pol := DefiningPolynomial(K, GF(q));
	w0 := Transpose(CompanionMatrix(pol));

  	f0 := ZeroMatrix(GF(q), v,v);
	for i in [1..v] do
        temp := Eltseq(z*w^(i-1), GF(q));
        temp := temp cat [0 : i in [1..(v-#temp)]];
        for j in [1..v] do
            f0[j][i] := temp[j];
        end for;
	end for;  

	phi0 := ZeroMatrix(GF(q), v,v);
	for i in [1..v] do
        temp := Eltseq(w^(q*(i-1)), GF(q));
        temp := temp cat [0 : i in [1..(v-#temp)]];
        for j in [1..v] do
            phi0[j][i] := temp[j];
        end for;
	end for;

	f   := DiagonalJoin([f0 : i in [1..mu]]);
	phi := DiagonalJoin([phi0 : i in [1..mu]]);

	// need to require that r divides q^v - 1 for all prime factors r of mu.

	// X = matrix from GL(mu,K)
	// return matrix in GL(mu*v, K) as a block matrix, with v x v blocks.
	// X[i][j] = 0   => zero matrix as (i,j) block.
	// X[i][j] = z^k => f0^k as (i,j) block.

	// alternative: do not use Log
	// use Eltseq() instead, and write as sum of powers of K.1 ..
	
	f_extension := function(X)
		O := ZeroMatrix(GF(q), v);
		f_BLOCKS := [];
		for i in [1..mu] do
			for j in [1..mu] do
				if X[i][j] eq 0 then
					Append(~f_BLOCKS, O);
				else 
					s := Eltseq(X[i][j], GF(q));
                    temp_pol := elt< R | s>;
					Append(~f_BLOCKS, Evaluate(temp_pol,w0));
				end if;
			end for;
		end for;
		return BlockMatrix(mu,mu,f_BLOCKS);
	end function;

	A_LISTS := [];
	B_LISTS := [];
	C_LISTS := [];
	D_LISTS := [];
	E_LISTS := [];

	cval := 1;

	for iter in [1..#M] do
		r := M[iter][1];
		l := M[iter][2];
		// extraspecial group of order r^(1+2l)

		ft,At,Bt,Ct,Dst,Et := ExtraSpecialNormalizerGenerators(r,l,q^v : GType := GType);
		

		I_LEFT := IdentityMatrix(K, cval);
		I_RIGHT := IdentityMatrix(K, mu div (cval * r^l));

		At  := [f_extension(TensorProduct(TensorProduct(I_LEFT, x), I_RIGHT)) : x in At];
		Bt  := [f_extension(TensorProduct(TensorProduct(I_LEFT, x), I_RIGHT)) : x in Bt];
		Ct  := [f_extension(TensorProduct(TensorProduct(I_LEFT, x), I_RIGHT)) : x in Ct];
		Dst := [f_extension(TensorProduct(TensorProduct(I_LEFT, x), I_RIGHT)) : x in Dst];
		Et  := [f_extension(TensorProduct(TensorProduct(I_LEFT, x), I_RIGHT)) : x in Et];

		Append(~A_LISTS, At);
		Append(~B_LISTS, Bt);
		Append(~C_LISTS, Ct);
		Append(~D_LISTS, Dst);
		Append(~E_LISTS, Et);

		cval := cval * r^l;

	end for;

	// prime factorization mu = r_1^a_1 ... r_k^a_k
	// list of generators for each prime factor.
	return A_LISTS, B_LISTS, C_LISTS, D_LISTS, E_LISTS, f, phi;

end function;


// return a list of GSpSOLR records corresponding to maximal irreducible solvable subgroups of GSp(2,r) = GL(2,r).
// assumption is that r is an odd prime.
GSp2_MIRS := function(r)

	if (r eq 2) or (not IsPrime(r)) then
		print "r should be an odd prime";
		return [];
	end if;

	RESULT := [];

	z := PrimitiveElement(GF(r));

	//
	// X = G_{1,1}^{B_1} is maximal irreducible solvable in GSp(2,q) = GL(2,q) except for q = 2, 3, 5.
	// 
	// Generators for X^circ = X \cap Sp(2,q):
	//
	// [ z 0    ]      [0  1 ]
	// [ 0 z^-1 ]  and [-1 0 ]
	// with z \in GF(r) primitive element.
	//
	// using generators 
	//      [ 1 1 ]           [ 1 0 ]
	// x := [ 0 1 ]      y := [ 1 1 ]
	// 
	// we can write the diagonal matrix diag(z,w) with zw = 1 as:
	//  y^-1 * x^(1-w) * y^z * x^(w^2-w)
	// 
	// here x = E_1 = <1,0,1>
	//      y = C_1 E_1^-1 C_1^-1 = <0,1,1>, <1,0,-1>, <0,1,-1>
	// 
	// X is maximal irreducible solvable in GSp(2,q) except for q = 2,3,5
	// X^\circ is maximal irreducible solvable in Sp(2,q) except for q = 2,3,5,7,9
	//
	// generator for X/X^circ : diag(z,1) with z := PrimitiveElement(GF(q));

	if r notin [3,5] then

		a := IntegerRing()!z;
		b := IntegerRing()!(z^-1);

		// sequence for diag(z,z^-1) in Sp(2,r)
		L1 := [<0,1,1>, <1,0,1>, <0,1,-1>, <1,0,1-b>,  <0,1,1>, <1,0,-a>, <0,1,-1>, <1,0,b^2-b>];
		//      C_1       E_1     C_1^-1    E_1^(1-w)   C_1      E_1^z   C_1^-1     E_1^(w^2-w)

		// sequence for other generator is just C_1
		L2 := [<0,1,1>];	
		//      C_1

		boo_maxcirc := true;
		// GL_1(q) wr S_2 is nonmaximal in Sp(2,q) for q = 7,9; note we only consider the case with r prime.
		if r eq 7 then
			boo_maxcirc := false;
		end if;

		R1 := rec< GSpSOLR |
			isometrygens := [L1, L2],
			multgen := DiagonalMatrix(GF(r), [z,1]),
			multiplier := 1,
			characteristic := r,
			type := "+",
			maximalXcirc := boo_maxcirc
		>;
		Append(~RESULT,R1);

	end if;

	// Generators for X:
	// 
	// Let z be a primitive element of GF(r^2)
	// Let pol(x) = x^2 + b0x + a0 be the minimal polynomial of z over GF(r)
	//
	//      [ 0 -a0 ]  
	// t := [ 1 -b0 ]  (companion matrix of pol(x), corresponds to GF(r)-linear map v -> zv on GF(r^2))
	//
	//      [ 1 Trace(z) ]
	// s := [ 0    -1    ]   (corresponds to GF(r)-linear map v -> v^r on GF(r^2)
	//
	//
	// Then <t,s> = X = GammaL(1,r^2).
	//
	// We have X^\circ = X \cap Sp(2,r) = <t0, s0> where 
	//
	// t0 := t^(r-1);   s0 := t^((r-1) div 2) * s;
	//
	// and X/X^\circ generated by image of t.
	//

	// type B_2 = GammaL(1,r^2). Not maximal solvable if r = 3.
	if r ne 3 then

		zr := PrimitiveElement(GF(r^2));
		t := Transpose(CompanionMatrix(MinimalPolynomial(zr)));
		s := Matrix(GF(r),2,2,[1,Trace(zr),0,-1]);

		t0 := t^(r-1);
		s0 := t^((r-1) div 2) * s;
		d1,d2,d3,d4 := sp2word(t0);
		e1,e2,e3,e4 := sp2word(s0);

		L1 := [<0,1,1>, <1,0,-d1>, <0,1,-1>, <1,0,d2>,  <0,1,1>, <1,0,-d3>, <0,1,-1>, <1,0,d4>];
		L2 := [<0,1,1>, <1,0,-e1>, <0,1,-1>, <1,0,e2>,  <0,1,1>, <1,0,-e3>, <0,1,-1>, <1,0,e4>];

		boo_maxcirc := true;
		if r eq 7 then
			boo_maxcirc := false;
		end if;

		R2 := rec< GSpSOLR |
			isometrygens := [L1, L2],
			multgen := t,
			multiplier := 1,
			characteristic := r,
			type := "+",
			maximalXcirc := boo_maxcirc
		>;

		Append(~RESULT,R2);

	end if;

	// type B_3: ( (q-1) o 2_{-}^{1+2} ) . O_2^{-}(2)
	// note that we are assuming r is an odd prime

	a,b := a2b2sol(r);
	rA := Matrix(GF(r),2,2,[a,b,b,-a]);
	rB := Matrix(GF(r),2,2,[0,-1,1,0]);
	rC := rA + rB;
	rE := rA + 1;
	rZ := Matrix(GF(r),2,2,[z,0, 0,z]);

	a1,a2,a3,a4 := sp2word(rA);
	b1,b2,b3,b4 := sp2word(rB);

	L1 := [<0,1,1>, <1,0,-a1>, <0,1,-1>, <1,0,a2>,  <0,1,1>, <1,0,-a3>, <0,1,-1>, <1,0,a4>];
	L2 := [<0,1,1>, <1,0,-b1>, <0,1,-1>, <1,0,b2>,  <0,1,1>, <1,0,-b3>, <0,1,-1>, <1,0,b4>];

	// multiplier 2 case; in this case there are two Sp(2,r)-classes
	if LegendreSymbol(2,r) eq 1 then

		nonC := DiagonalMatrix(GF(r), [PrimitiveElement(GF(r)), 1]); // element with nonsquare determinant

		rA_H := nonC * rA * nonC^-1;
		rB_H := nonC * rB * nonC^-1;
		a1_H,a2_H,a3_H,a4_H := sp2word(rA_H);
		b1_H,b2_H,b3_H,b4_H := sp2word(rB_H);

		L1_H := [<0,1,1>, <1,0,-a1_H>, <0,1,-1>, <1,0,a2_H>,  <0,1,1>, <1,0,-a3_H>, <0,1,-1>, <1,0,a4_H>];
		L2_H := [<0,1,1>, <1,0,-b1_H>, <0,1,-1>, <1,0,b2_H>,  <0,1,1>, <1,0,-b3_H>, <0,1,-1>, <1,0,b4_H>];		


		sq2 := Root(GF(r)!2,2);
		rC2 := 1/sq2 * rC;
		rE2 := 1/sq2 * rE;
		c1,c2,c3,c4 := sp2word(rC2);
		d1,d2,d3,d4 := sp2word(rE2);

		rC2_H := nonC * rC2 * nonC^-1;
		rE2_H := nonC * rE2 * nonC^-1;

		c1_H,c2_H,c3_H,c4_H := sp2word(rC2_H);
		d1_H,d2_H,d3_H,d4_H := sp2word(rE2_H);


		L3 := [<0,1,1>, <1,0,-c1>, <0,1,-1>, <1,0,c2>,  <0,1,1>, <1,0,-c3>, <0,1,-1>, <1,0,c4>];
		L4 := [<0,1,1>, <1,0,-d1>, <0,1,-1>, <1,0,d2>,  <0,1,1>, <1,0,-d3>, <0,1,-1>, <1,0,d4>];

		L3_H := [<0,1,1>, <1,0,-c1_H>, <0,1,-1>, <1,0,c2_H>,  <0,1,1>, <1,0,-c3_H>, <0,1,-1>, <1,0,c4_H>];
		L4_H := [<0,1,1>, <1,0,-d1_H>, <0,1,-1>, <1,0,d2_H>,  <0,1,1>, <1,0,-d3_H>, <0,1,-1>, <1,0,d4_H>];

		R3 := rec< GSpSOLR |
			isometrygens := [L1, L2, L3, L4],
			isometrygens_nonsquare := [L1_H, L2_H, L3_H, L4_H],
			multgen := DiagonalMatrix(GF(r), [z,z]),
			multiplier := 2,
			characteristic := r,
			type := "+",
			maximalXcirc := true
		>;

	else

		rCE := rC * rE^-1;
		c1,c2,c3,c4 := sp2word(rCE);
		L3 := [<0,1,1>, <1,0,-c1>, <0,1,-1>, <1,0,c2>,  <0,1,1>, <1,0,-c3>, <0,1,-1>, <1,0,c4>];

		cf := Root(z/2,2);

		R3 := rec< GSpSOLR |
			isometrygens := [L1, L2, L3],
			multgen := rC * DiagonalMatrix(GF(r), [cf,cf]),
			multiplier := 1,
			characteristic := r,
			type := "+",
			maximalXcirc := true
		>;

	end if;

	Append(~RESULT,R3);

	return RESULT;

end function;

RECtoGroup := function(X)

	n := NumberOfRows(X`multgen);
	l := n div 2;
	r := X`characteristic;

	T := [];

	if X`characteristic ne 2 then
		T := [CDEseqtoelt(x,l,r) : x in X`isometrygens];
	elif X`characteristic eq 2 and X`type eq "+" then
		T := [CDseqtoeltPlus(x,l) : x in X`isometrygens];
	elif X`characteristic eq 2 and X`type eq "-" then
		T := [CDseqtoeltMinus(x,l) : x in X`isometrygens];
	end if;

	return sub<GL(n,r) | T, X`multgen>;

end function;

//
// Generators for group G = G_{mu,v}(X_1, ..., X_k) of type B_0 
// here mu = r_1^{l_1} ... r_k^{l_k} prime factorization of mu
// r_i divides q^v - 1 for all 1 <= i <= k
// X_i is metrically completely reducible maximal solvable in GSp(2l_i, r_i) for all 1 <= i <= k
// generators given as follows:
// return f,A_LISTS,B_LISTS,I_LISTS,g_elt;
// Notes:
//        G is generated by C_G(F_0) and g_elt.
//        C_G(F_0) is generated by f, A_LISTS, B_LISTS, and I_LISTS.
//        Fit(C_G(F_0)) is generated by f, A_LISTS, B_LISTS
//        I_LISTS images generate X_1^\circ x ... X_k^\circ,
//        where X_i^\circ = X_i \cap Sp(2l_i,r_i).
//
// in the arguments, X is a list with elements of type GSpSOLR, for each prime divisor r_1, ..., r_k
//
SingerTypeB0gens := function(mu,v,q,X : GType := "+")

	if mu eq 1 then
		G,f,phi := SingerTypeB0(v,q);
		return f,[],[],[],phi;
	end if;

	n := mu*v;
	M := Factorization(mu);

	A_LISTS, B_LISTS, C_LISTS, D_LISTS, E_LISTS, f, phi := SingerTypeB0base(mu,v,q : GType := GType);

	// generators, for each 1 <= i <= k that give the inverse image 
	// of X_1^\circ x ... x X_k^\circ, and thus with A_0 generate C_G(F_0).
	I_LISTS := [];

	for iter in [1..#M] do
		r := M[iter][1];    // this should be equal to X[iter]`characteristic
		l := M[iter][2];

		T := X[iter]`isometrygens; // of type GSpSOLR

		A := A_LISTS[iter]; 
		B := B_LISTS[iter];	
		C := C_LISTS[iter];	
		D := D_LISTS[iter];	
		E := E_LISTS[iter];	

		I_GENS := [];

		//
		// Note: Index of D_{s,t} for 1 <= s < t <= l in list D is equal to
		// Binomial(l,2) - Binomial(l-s+1,2) + (t-s)
		//
		
		if  (r ne 2) then

			// <t,0,x> = E_t^x
            // <0,t,x> = C_t^x
            // <s,t,x> = D_{st}^x

			for i in [1..#T] do

				temp := IdentityMatrix(GF(q),n);

				for j in [1..#T[i]] do

					tu := T[i][j];
					if tu[1] eq 0 then
						// C_t^x
						temp := temp * C[tu[2]]^tu[3];
					elif tu[2] eq 0 then
						// E_t^x
						temp := temp * E[tu[1]]^tu[3];
					elif (tu[1] ne 0) and (tu[2] ne 0) then
						// D_{s,t}^x
						dindex := Binomial(l,2) - Binomial(l-tu[1]+1,2) + tu[2]-tu[1];
						temp := temp * D[dindex]^tu[3];
					end if;
				end for;

				Append(~I_GENS, temp);

			end for;

		elif (r eq 2) and (GType eq "+") then
		    //
			// <s,t> = D_{st}   for 1 <= s < t <= l
			// <t,t> = C_t      for 1 <= t <= l
			
			for i in [1..#T] do
				temp := IdentityMatrix(GF(q),n);
				for j in [1..#T[i]] do
					tu := T[i][j];
					if (tu[1] eq tu[2]) then
						// C_t
						temp := temp * C[tu[1]];
					elif (tu[1] ne tu[2]) then
						// D_{s,t}
						dindex := Binomial(l,2) - Binomial(l-tu[1]+1,2) + tu[2]-tu[1];
						temp := temp * D[dindex];
					end if;
				end for;
				Append(~I_GENS, temp);
			end for;


		elif (r eq 2) and (GType eq "-") then
			// <s,t> = D_{st}      for 1 <= s < t <= l-1
			// <s,l> = D_{s,l}'    for 1 <= s <= l-1
			// <t,t> = C_t         for 1 <= t <= l-1
			// <l,l> = C_l'
			// <0,0> = E_l'

			// Append the elements from T
			for i in [1..#T] do

				temp := IdentityMatrix(GF(q),n);

				for j in [1..#T[i]] do
					tu := T[i][j];
					if (tu[1] eq tu[2]) then
						if tu[1] ne 0 then
							// C_t
							temp := temp * C[tu[1]];
						else
							// E_t
							temp := temp * E[l];
						end if;
					elif (tu[1] ne tu[2]) then
						// D_{s,t}
						dindex := Binomial(l,2) - Binomial(l-tu[1]+1,2) + tu[2]-tu[1];
						temp := temp * D[dindex];
					end if;
				end for;
				Append(~I_GENS, temp);
			end for;
		end if;

		Append(~I_LISTS, I_GENS);

	end for;

	//
	// next: generator for G/C_G(F_0).
	//
	// generator is of the form g * psi^x; where
	// x = 1  if Legendre(q,r) = + for all  X_i with multiplier 2.
	// x = 2  if Legendre(q,r) = - for some X_i with multiplier 2.
    //
	phi_x := 1;

	for iter in [1..#M] do
		r := M[iter][1]; 
		if (X[iter]`multiplier eq 2) and (LegendreSymbol(q,r) eq -1) then
			phi_x := 2;
			break;
		end if;
	end for;

	//print "Construction with q = ",q,"mu = ",mu,"v = ",v," with phi_x = ",phi_x;

	g_ELTS := [];

	for iter in [1..#M] do
		
		r := M[iter][1]; 
		l := M[iter][2]; 

		A := A_LISTS[iter]; 
		B := B_LISTS[iter];	
		C := C_LISTS[iter];	
		D := D_LISTS[iter];	
		E := E_LISTS[iter];	

		if r ne 2 then
			// now q^phi_x = zr^pt (mod r); where zr = PrimitiveElement(GF(r));
			pt := Log(GF(r)!(q^phi_x)); 
			
			// divide by multiplier, so now g^pt and phi^phi_x multiply form by the
			// same scalar; where g is the generator of X_i/X_i^circ 
			pt := pt div X[iter]`multiplier;
			
			// g^pt * (image of phi)^(-phi_x) = in Sp(2l,r_i) => write in terms of CDE's
			gi := (X[iter]`multgen)^pt * DiagonalMatrix(GF(r), [q^(-phi_x) : i in [1..l]] cat [1 : i in [1..l]]);

			T := CDEwordSP(gi);
			
			temp := IdentityMatrix(GF(q),n);
			
			for i in [1..#T] do

				tu := T[i];

				if tu[1] eq 0 then
					// C_t^x
					temp := temp * C[tu[2]]^tu[3];
				elif tu[2] eq 0 then
					// E_t^x
					temp := temp * E[tu[1]]^tu[3];
				elif (tu[1] ne 0) and (tu[2] ne 0) then
					// D_{s,t}^x
					dindex := Binomial(l,2) - Binomial(l-tu[1]+1,2) + tu[2]-tu[1];
					temp := temp * D[dindex]^tu[3];
				end if;

			end for;

			g_ELTS[iter] := temp;

			//g_[iter] := pt;
		else
			g_ELTS[iter] := IdentityMatrix(GF(q),n);
		end if;

	end for;

	// now:
	// g_ELTS[1] * ... g_ELTS[k] * phi^(phi_x) is contained in X_1 x ... x X_k
	//

	g_elt := IdentityMatrix(GF(q),n);
	for iter in [1..#M] do
		g_elt := g_elt * g_ELTS[iter];
	end for;
	g_elt := g_elt * phi^phi_x;

	// G is generated by C_G(F_0) and g_elt.
	// C_G(F_0) is generated by f, A_LISTS, B_LISTS, and I_LISTS.
	//
	return f,A_LISTS,B_LISTS,I_LISTS,g_elt;

end function;

// using the lists generated by SingerTypeB0gens, return the corresponding group
// G = G_{mu,v}(X_1, ..., X_k)
SingerTypeB0group := function(mu,v,q,X : GType := "+")

	if mu eq 1 then
		G,f,phi := SingerTypeB0(v,q);
		return G;
	end if;

	f,A_LISTS,B_LISTS,I_LISTS,g_elt := SingerTypeB0gens(mu,v,q,X : GType := GType);

	A := [];
	for x in A_LISTS do
		A := A cat x;
	end for;

	B := [];
	for x in B_LISTS do
		B := B cat x;
	end for;

	I := [];
	for x in I_LISTS do
		I := I cat x;
	end for;

	return sub<GL(mu*v,q) | f,A,B,I,g_elt>;
end function;


// L = [[X_1^1, ..., X_k1^1], ... [X_1^t, ..., X_kt^t]]
// return the list of all [X_j1^1, ..., X_jt^t]
// e.g. L = [ [ 1, 2 ], [ 3 ], [ 9, 10 ] ]
//  returns the list
//    [ [ 1, 3, 9 ], [ 2, 3, 9 ], [ 1, 3, 10 ], [ 2, 3, 10 ] ]
ListTuples := function(L)

	if #L eq 0 then
		return [[]];
	end if;

	if #L eq 1 then
		return [[x] : x in L[1]];
	end if;

	K := $$(L[2..#L]);
	return [ [x] cat y : x in L[1], y in K];

end function;

// for integer n, return a list of all prime powers
// [x_1, ..., x_t] with n = x_1 ... x_t.
WreathSequences := function(n)

	if IsPrime(n) then
		return [[n]];
	end if;

	if n eq 1 then
		return [[]];
	end if;

	M := Factorization(n);
	RESULT := [];

	for i in [1..#M] do
		p := M[i][1];
		k := M[i][2];

		for j in [1..k] do
			temp := $$(n div p^j);
			temp := [[p^j] cat x : x in temp];
			for y in temp do
				Append(~RESULT,y);
			end for;
		end for;
	end for;

	return RESULT;

end function;

// list of lists of permutation groups L = [[X_1^1, ..., X_t1^1], ..., [X_1^k, ..., X_tk^k]] 
// return all possible wreath products X_i1^1 wr X_i2^2 wr ... wr X_tk^k
WreathGroupsFromSequences := function(L)

	if #L eq 0 then
		return [];
	end if;

	if #L eq 1 then
		return L[1];
	end if;

	K := $$(L[2..#L]);
	return [WreathProduct(x,y) : x in L[1], y in K];

end function;

//
// l >= 1 integer
// r >= 2 prime.
//
// return a list of metrically completely reducible maximal solvable subgroups 
// of GSp(2l,r), in GSpSOLR format.
//
// For r = 2, this will return the union of such subgroups from
// O^+(2l,2) and O^-(2l,2).
//
// implemented only for certain values of l and r.
//
MIRC_GSp := function(l,r)

	// to get the list of defined variables: ShowIdentifiers(); 

		RESULT := [];

		if r eq 2 then
			if l eq 1 then
				return [
					REC_GOMinus2_G1
				];
			elif l eq 2 then
				return [
					REC_GOPlus4_G1, 
					REC_GOMinus4_G1
				];
			elif l eq 3 then
				return [
					REC_GOPlus6_G1,                                     
					REC_GOPlus6_G2, 
					REC_GOMinus6_G1,                                     
					REC_GOMinus6_G2
				];
			elif l eq 4 then
				return [
					REC_GOPlus8_G1,                                         
					REC_GOPlus8_G2,                                        
					REC_GOPlus8_G3,                                        
					REC_GOPlus8_G4,  
					REC_GOMinus8_G1,      
					REC_GOMinus8_G2,                                       
					REC_GOMinus8_G3  
				];
			elif l eq 5 then
				return [
					REC_GOPlus10_G1,     
					REC_GOPlus10_G2,   
					REC_GOPlus10_G3,   
					REC_GOPlus10_G4,   
					REC_GOPlus10_G5,                                         
					REC_GOMinus10_G1,     
					REC_GOMinus10_G2,
					REC_GOMinus10_G3,
					REC_GOMinus10_G4,
					REC_GOMinus10_G5,
					REC_GOMinus10_G6,
					REC_GOMinus10_G7,
					REC_GOMinus10_G8 
				];
			elif l eq 6 then
				return [
					REC_GOPlus12_G1,     
					REC_GOPlus12_G2,   
					REC_GOPlus12_G3,   
					REC_GOPlus12_G4,   
					REC_GOPlus12_G5, 
					REC_GOPlus12_G6,     
					REC_GOPlus12_G7,   
					REC_GOPlus12_G8,   
					REC_GOPlus12_G9,   
					REC_GOPlus12_G10, 
					REC_GOPlus12_G11,
					REC_GOPlus12_G12,
					REC_GOPlus12_G13,                                       
					REC_GOMinus12_G1,     
					REC_GOMinus12_G2,
					REC_GOMinus12_G3,
					REC_GOMinus12_G4,
					REC_GOMinus12_G5,
					REC_GOMinus12_G6,
					REC_GOMinus12_G7,
					REC_GOMinus12_G8, 
					REC_GOMinus12_G9 
				];	
			else
				print "O^{+,-}(" cat IntegerToString(2*l) cat ", 2) not implemented";
				return [];
			end if;
		end if;

		// r > 2 and l = 1.
		if l eq 1 then
			return GSp2_MIRS(r);
		end if;

		// GSp(4,3); GSp(4,5); GSp(4,7).
		if r in [3,5,7,11] and (l eq 2) then
			if r eq 3 then
				return [
					REC_GSp4_3_G1,                                         
					REC_GSp4_3_G2,                      
					REC_GSp4_3_G3, 
					REC_GSp4_3_G4 
				];
			elif r eq 5 then
				return [
					REC_GSp4_5_G1,                     
					REC_GSp4_5_G2,                      
					REC_GSp4_5_G3,
					REC_GSp4_5_G4,
					REC_GSp4_5_G5,
					REC_GSp4_5_G6,
					REC_GSp4_5_G7
				];
			elif r eq 7 then
				return [
					REC_GSp4_7_G1,
					REC_GSp4_7_G2, 
					REC_GSp4_7_G3, 
					REC_GSp4_7_G4, 
					REC_GSp4_7_G5, 
					REC_GSp4_7_G6, 
					REC_GSp4_7_G7, 
					REC_GSp4_7_G8, 
					REC_GSp4_7_G9, 
					REC_GSp4_7_G10
				];
			elif r eq 11 then
				return [
					REC_GSp4_11_G1,
					REC_GSp4_11_G2,
					REC_GSp4_11_G3,
					REC_GSp4_11_G4,
					REC_GSp4_11_G5,
					REC_GSp4_11_G6,
					REC_GSp4_11_G7,
					REC_GSp4_11_G8,
					REC_GSp4_11_G9,
					REC_GSp4_11_G10,
					REC_GSp4_11_G11
				];
			end if;
			
		end if;

		// GSp(6,3).
		if r in [3,5] and (l eq 3) then
			if r eq 3 then
			return [
					REC_GSp6_3_G1, 
					REC_GSp6_3_G2,
					REC_GSp6_3_G3,                               
					REC_GSp6_3_G4,  
					REC_GSp6_3_G5,
					REC_GSp6_3_G6
			];
			elif r eq 5 then
			return [
					REC_GSp6_5_G1,
					REC_GSp6_5_G2,
					REC_GSp6_5_G3,
					REC_GSp6_5_G4,
					REC_GSp6_5_G5,
					REC_GSp6_5_G6,
					REC_GSp6_5_G7,
					REC_GSp6_5_G8,
					REC_GSp6_5_G9,
					REC_GSp6_5_G10,
					REC_GSp6_5_G11,
					REC_GSp6_5_G12,
					REC_GSp6_5_G13,
					REC_GSp6_5_G14,
					REC_GSp6_5_G15
			];
			end if;
		end if;

		// GSp(8,3)
		if (r eq 3) and (l eq 4) then
			return [
					REC_GSp8_3_G1,
					REC_GSp8_3_G2,
					REC_GSp8_3_G3,
					REC_GSp8_3_G4,
					REC_GSp8_3_G5,
					REC_GSp8_3_G6,
					REC_GSp8_3_G7,
					REC_GSp8_3_G8,
					REC_GSp8_3_G9,  
					REC_GSp8_3_G10,
					REC_GSp8_3_G11,
					REC_GSp8_3_G12,
					REC_GSp8_3_G13,
					REC_GSp8_3_G14,
					REC_GSp8_3_G15,
					REC_GSp8_3_G16,
					REC_GSp8_3_G17,
					REC_GSp8_3_G18
			];
		end if;

		// remaining cases:
		// r > 7 with l > 1.
		// r = 7, l > 2.
		// r = 5, l > 3.
		// r = 3, l > 4.
		print "GSp(" cat IntegerToString(2*l) cat ", " cat IntegerToString(r) cat ") not implemented";
		return [];

end function;

//
// return a list of maximal irreducible solvable subgroups GL(n,q) (representative for each conjugacy class of subgroups)
//
// if PRIMITIVE_ONLY is set to true, then return only the ones which 
// are primitive maximal irreducible solvable.
//
// implemented only for certain values of n, but for arbitrary q.
// (Could be implemented for arbitrary n.)
//
// Currently implemented values: 
//               n = 2^a * 3^b * 5^c * 7^d * 11^e * ...
//               where:
//               0 <= a <= 6
//               0 <= b <= 4
//               0 <= c <= 3
//               0 <= d,e <= 2
//               for all other primes, exponent <= 1.
// 
// In particular, this works for all 1 <= n <= 127. Also works for all squarefree n.
//
intrinsic MIRSGL(n::RngIntElt, q::RngIntElt : PRIMITIVE_ONLY := false) -> SeqEnum
{ 
List of the maximal irreducible solvable subgroups of GL(n,q), up to conjugacy. 
If PRIMITIVE_ONLY is set to true, return only the primitive maximal irreducible solvable subgroups.
}
require n ge 1 : "Argument 1 must be a positive integer";
require #PrimeFactors(q) eq 1 : "Argument 2 must be a prime power";

	// n = 1; GL(1,q) is solvable
	if n eq 1 then
		return [GL(1,q)];
	end if;

	M := Factorization(n);

	// check if the value has been implemented
	icheck := true;
	for x in M do
		// GO^{+-}(2l,2) for 1 <= l <= 5.
		if (x[1] eq 2) and (x[2] ge 7) then
			icheck := false;
			break;
		end if;

		// GSp(2,3), GSp(4,3), GSp(6,3).
		if (x[1] eq 3) and (x[2] ge 5) then
			icheck := false;
			break;
		end if;

		// GSp(2,5), GSp(4,5), GSp(6,5).
		if (x[1] eq 5) and (x[2] ge 4) then
			icheck := false;
			break;
		end if;

		// GSp(2,7), GSp(4,7).
		if (x[1] eq 7) and (x[2] ge 3) then
			icheck := false;
			break;
		end if;

		// GSp(2,11), GSp(4,11).
		if (x[1] eq 11) and (x[2] ge 3) then
			icheck := false;
			break;
		end if;

		if (x[1] gt 11) and (x[2] ge 2) then
			icheck := false;
			break;
		end if;

	end for;

	// if not icheck then
	//	print "Degree n = " cat IntegerToString(n) cat " not implemented";
	//	return [];
	// end if;

	require icheck : "Degree n = " cat IntegerToString(n) cat " not available";

	RESULT := [];

	// construction of imprimitive subgroups
	if not PRIMITIVE_ONLY then

		for d in Divisors(n) do
			if d lt n then

				D := $$(d,q : PRIMITIVE_ONLY := true);
				E := WreathSequences(n div d);
				// E consists of lists S = [n_1, ..., n_k],
				// such that n_i > 1 are prime powers with n = d n_1 ... n_k.
				for S in E do

					admissible := true;
					for i in [1..(#S - 1)] do
						if (S[i] eq 2) and (S[i+1] eq 2) then
							admissible := false;
							break;
						end if;
					end for;

					if d eq 1 then

						// GL_1(2) wr (..) is not irreducible
						if q eq 2 then 
							admissible := false;
						end if;

						// GL_1(q) wr S_2 not maximal solvable if q = 2,3,5
						if (S[1] eq 2) and q in [2,3,5] then
							admissible := false;
						end if;

						// GL_1(q) wr S_3 not maximal solvable if q = 2,4
						if (S[1] eq 3) and q in [2,4] then
							admissible := false;
						end if;

						// GL_1(q) wr S_4 not maximal solvable if q = 2,3
						if (S[1] eq 4) and q in [2,3] then
							admissible := false;
						end if;

					end if;

					if admissible then
						
						Q := [];

						for i in [1..#S] do
							temp := Factorization(S[i]);
							temp := temp[1];
							pi := temp[1];
							ni := temp[2];
							Q[i] := [AffineGroup(x) : x in $$(ni,pi)];
						end for;

						WGPS := WreathGroupsFromSequences(Q);

						RESULT := RESULT cat [WreathProduct(x,y) : x in D, y in WGPS];

					end if;

				end for;

			end if;

		end for;

	end if;

	// construction of primitive subgroups
	// G_{\mu,\nu}^{B_0}(X_1, ..., X_k)
	for mu in Divisors(n) do

		if mu eq 1 then
			// GammaL(1,3^2) not maximal solvable in GL(2,3)
			if (q ne 3) or (n ne 2) then
				Append(~RESULT, SingerTypeB0(n,q));
			end if;
		else
			v := n div mu;

			admissible := true;
			val := q^v - 1;

            // G_{\mu,\nu}^{B_0}(X_1, ..., X_k) is only defined when r divides q^v - 1 for all prime factors r of mu
			for r in PrimeFactors(mu) do
				if (val mod r) ne 0 then
					admissible := false;
					break;
				end if;
			end for;

			M := Factorization(mu);

			// type B_0 with q = 3, v = 2 is not maximal solvable.
			if (q eq 3) and (v eq 2) then
				admissible := false;
			end if;

			if admissible then
				// at this point construct list 
				// L = [A_1, ..., A_k]
				
				// A_i = [ list of MIRC-subgroups (in rec GSpSOLR format) of GSp(2l_i,r_i)]
				// this includes for r_i = 2, the type is included
				// then: construction of LX = [[X_1, ..., X_k] : ...] potential candidates
				// G_{mu,v}(X_1, ..., X_k) to go through..
				L := [];

				for i in [1..#M] do
					r := M[i][1];
					l := M[i][2];
					L[i] := MIRC_GSp(l,r);
				end for;

				LX := ListTuples(L);

				for Q in LX do
					//
					// Q = [X_1, ..., X_k] with X_i GSpSOLR record for ith prime factor.
					// we need to rule out cases where 
					// r_i = 7
					// X_i^circ is not maximal solvable in Sp(2l_i,r_i)
					// either Legendre(q,7) = +
					// or Legendre(q,r_j) = - for some X_j of multiplier 2.
					// in these cases G_{\mu,\nu}^{\B_0}(X_1, ..., X_k) is not maximal solvable
					// (set admissibleX to "false" in such cases)
					//
					admissibleX := true;
					
					check7 := false;
					if (mu mod 7) eq 0 then
						for i in [1..#M] do
							if M[i][1] eq 7 then
								check7 := not Q[i]`maximalXcirc;
								break;
							end if;
						end for;
					end if;

					if check7 then
						if LegendreSymbol(q,7) eq 1 then
							admissibleX := false;
						else
							for i in [1..#M] do
								if Q[i]`multiplier eq 2 then
									if LegendreSymbol(q,M[i][1]) eq -1 then
										admissibleX := false;
										break;
									end if;
								end if;
							end for;
						end if;
					end if;

					// conjugacy
					// let I = indices such that X_i is of multiplier 2.
					// let J = indices in I such that Legendre(q,r_i) = +.
					// Let X_i^+, X_i^- be representatives for the Sp(2l_i,r_i)-classes of X_i when X_i is of multiplier 2 
					// Let X_i^+ = X_i when X_i is of multiplier 1.
					// The groups considered at this point are of the form G(X_1^{\alpha_1}, ... X_k^{\alpha_k}) with \alpha_i \in {+,-}
					// and \alpha_i = + when X_i is of multiplier 1.
					//
					//
					// G(X_1^{\alpha_1}, ..., X_k^{\alpha_k}) conjugate to G(X_1^{\beta_1}, ..., X_k^{\beta_k})
					// if and only if \alpha = \beta for all I;
					//               OR \alpha = \beta for all J; and \alpha = -\beta for I notin J.
					// 
					// Thus the number of GL(n,q)-conjugacy classes of subgroups of this type is: 
					//  2^|I|;     if  I  = J.
					//  2^{|I|-1}; if  I != J.
					//  
					// Representatives given as follows. 
					// If I = J, then just G(X_1^{\alpha_1}, ..., X_k^{\alpha_k}) with the 2^{|I|} possible values give representatives.
					// If I != J, then let i_0 = some element in I \ J. (This is fixed_ix below.)
					// Then any of these group can be conjugated to one with \alpha_{i_0} = +.
					// So only consider ones with \alpha_{i_0} = +.
					// Running over the 2^{|I|-1} other possible values of signs gives representatives.
					//

					if admissibleX then

						typeX := "+";
						if (mu mod 2) eq 0 then
							typeX := Q[1]`type;
						end if;

						ixI := [i : i in [1..#M] | Q[i]`multiplier eq 2];
						ixJ := [i : i in ixI | LegendreSymbol(q, M[i][1]) eq 1];												

						// if ixI != ixJ, this shall be the first element of ixI \ ixJ
						fixed_ix := 0;
						if #ixI gt #ixJ then
							fixed_ix := [i : i in ixI | i notin ixJ][1];
						end if;

						//print "n = ",n,"mu = ",mu,"v = ",v,"q = ",q,"... ixI:",ixI;
						//print "n = ",n,"mu = ",mu,"v = ",v,"q = ",q,"... ixJ:",ixJ;
						//print "n = ",n,"mu = ",mu,"v = ",v,"q = ",q,"... fixed_ix:",fixed_ix;
						//print "";

						QPM := [];

						for i in [1..#M] do
							if (Q[i]`multiplier eq 1) or (i eq fixed_ix) then
								QPM[i] := [ Q[i] ];
							else
								Xminus := Q[i];
								temp := Xminus`isometrygens;
								Xminus`isometrygens := Xminus`isometrygens_nonsquare;
								Xminus`isometrygens_nonsquare := temp;
								QPM[i] := [ Q[i], Xminus ];
							end if;
						end for;

						QTUPLES := ListTuples(QPM);

						for Q0 in QTUPLES do

							G := SingerTypeB0group(mu,v,q,Q0 : GType := typeX);
							Append(~RESULT, G);

						end for;

					end if;

				end for;

			end if;
		end if;

	end for;

	return RESULT;

end intrinsic;
